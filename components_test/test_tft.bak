#include <Arduino.h>
#include <TFT_eSPI.h>
#include <SPI.h>
#include <LittleFS.h>

#define FONT_FILENAME "DejaVuSansMono-Bold-40"
// TFT_eSPI tft = TFT_eSPI();

/*

uint16_t read16(fs::File &f) {
  uint16_t result;
  ((uint8_t *)&result)[0] = f.read(); // LSB
  ((uint8_t *)&result)[1] = f.read(); // MSB
  return result;
}

uint32_t read32(fs::File &f) {
  uint32_t result;
  ((uint8_t *)&result)[0] = f.read(); // LSB
  ((uint8_t *)&result)[1] = f.read();
  ((uint8_t *)&result)[2] = f.read();
  ((uint8_t *)&result)[3] = f.read(); // MSB
  return result;
}

void drawBmp(const char *filename, int16_t x, int16_t y) {

  if ((x >= tft.width()) || (y >= tft.height())) return;

  fs::File bmpFS;

  // Open requested file on SD card
  bmpFS = LittleFS.open(filename, "r");


  if (!bmpFS)
  {
    Serial.print("File not found");
    return;
  }

  uint32_t seekOffset;
  uint16_t w, h, row, col;
  uint8_t  r, g, b;

  uint32_t startTime = millis();

  if (read16(bmpFS) == 0x4D42)
  {
    read32(bmpFS);
    read32(bmpFS);
    seekOffset = read32(bmpFS);
    read32(bmpFS);
    w = read32(bmpFS);
    h = read32(bmpFS);

    if ((read16(bmpFS) == 1) && (read16(bmpFS) == 24) && (read32(bmpFS) == 0))
    {
      y += h - 1;

      bool oldSwapBytes = tft.getSwapBytes();
      tft.setSwapBytes(true);
      bmpFS.seek(seekOffset);

      uint16_t padding = (4 - ((w * 3) & 3)) & 3;
      uint8_t lineBuffer[w * 3 + padding];

      for (row = 0; row < h; row++) {
        
        bmpFS.read(lineBuffer, sizeof(lineBuffer));
        uint8_t*  bptr = lineBuffer;
        uint16_t* tptr = (uint16_t*)lineBuffer;
        // Convert 24 to 16-bit colours
        for (uint16_t col = 0; col < w; col++)
        {
          b = *bptr++;
          g = *bptr++;
          r = *bptr++;
          *tptr++ = ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
        }

        // Push the pixel row to screen, pushImage will crop the line if needed
        // y is decremented as the BMP image is drawn bottom up
        tft.pushImage(x, y--, w, 1, (uint16_t*)lineBuffer);
      }
      tft.setSwapBytes(oldSwapBytes);
      Serial.print("Loaded in "); Serial.print(millis() - startTime);
      Serial.println(" ms");
    }
    else Serial.println("BMP format not recognized.");
  }
  bmpFS.close();
}
*/

TFT_eSPI tft = TFT_eSPI();

enum DeviceState {
  SLEEPING,
  AWAKENING,
  LISTENING,
  THINKING,
  SPEAKING,
  HAPPY,
  POMODORO_FOCUS,
  SAD_ERROR,
  DEBUGGING
};

DeviceState currentState = SLEEPING;


const char* getFaceString(DeviceState state) {
  switch (state) {
    case SLEEPING:
      return "(⇀‿‿↼)";
    case AWAKENING:
      return "(≖‿‿≖)";
    case LISTENING:
      return "( ⚆_⚆)";
    case THINKING:
      return "(✜‿‿✜)";
    case SPEAKING:
      return "(◕‿‿◕)";
    case HAPPY:
      return "(•‿‿•)";
    case POMODORO_FOCUS:
      return "(⌐■_■)";
    case SAD_ERROR:
      return "(╥☁╥ )";
    case DEBUGGING:
      return "(#__#)";
    default:
      return "(☓‿‿☓)"; // A "broken" face for any unknown state
  }
}

void drawCurrentFace() {
  const char* face = getFaceString(currentState);

  tft.fillRect(0, 50, 320, 140, TFT_BLACK);

  tft.setTextColor(TFT_WHITE);

  tft.drawString(face, 160, 120);
}

void drawHeader() {
  tft.setTextColor(TFT_WHITE);
  tft.drawString("Device State Display", 160, 25);
}

void setup() {
  Serial.begin(115200);

  if (!LittleFS.begin()) {
    Serial.println("FATAL: LittleFS Mount Failed.");
    return;
  }
  Serial.println("LittleFS Mounted Successfully.");

  tft.init();
  tft.setRotation(0);
  tft.fillScreen(TFT_BLACK);

  tft.setTextDatum(MC_DATUM);

  tft.loadFont(FONT_FILENAME, LittleFS);

  // Now, check if the font was loaded successfully.
  if (tft.fontLoaded) {
    Serial.println("Smooth Font loaded successfully!");
  } else {
    Serial.println("FATAL: Failed to load font file " FONT_FILENAME);
    // As a backup, fall back to a built-in legacy font
    tft.setTextFont(4);
  }

  // Initial face draw
  drawCurrentFace();
}

// A variable to track time for the non-blocking delay
unsigned long previousMillis = 0;
const long interval = 5000; // 5 seconds

void loop() {
  unsigned long currentMillis = millis();

  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;

    int nextState = (int)currentState + 1;
    if (nextState > DEBUGGING) {
      nextState = SLEEPING;
    }
    
    currentState = (DeviceState)nextState;
    
    drawCurrentFace();
  }
}

